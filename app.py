import os
import json
from flask import Flask, request, render_template, send_file
from werkzeug.utils import secure_filename
from summarizer import MeetingSummarizer
from io import BytesIO

# --- Flask App Configuration ---
# Folder setup
UPLOAD_FOLDER = 'uploads'
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)

ALLOWED_EXTENSIONS = {'mp3', 'wav', 'm4a', 'flac'}

# Initialize Flask, explicitly telling it to use the 'frontend' folder for templates
app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

# Initialize the summarizer class globally 
# This loads the heavy Whisper model only once when the server starts.
summarizer = MeetingSummarizer() 

def allowed_file(filename):
    """Checks if the file extension is allowed."""
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

@app.route('/', methods=['GET'])
def index():
    """Renders the upload form."""
    return render_template('index.html')

@app.route('/summarize', methods=['POST'])
def summarize_meeting():
    """Handles the file upload and summarization process."""
    
    # 1. Validate file upload
    if 'audio_file' not in request.files:
        return render_template('index.html', error='No file part in the request.')
    
    file = request.files['audio_file']
    
    if file.filename == '':
        return render_template('index.html', error='No file selected for upload.')
    
    # 2. Process and save the file
    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        
        # Save the audio file temporarily
        file.save(filepath)
        
        transcript = "N/A"
        summary_data = {}

        try:
            # 3. RUN CORE LOGIC (Transcription)
            print(f"Starting transcription for: {filepath}")
            transcript = summarizer.transcribe_audio(filepath)

            if "Error" in transcript:
                 # Pass the error back through the summary data structure
                 summary_data = {"error": f"Transcription failed: {transcript}"}
            else:
                # 4. RUN CORE LOGIC (Summarization/Action Items)
                print("Starting LLM summarization...")
                summary_data = summarizer.summarize_transcript(transcript)
                
        except Exception as e:
            print(f"An unexpected error occurred in the pipeline: {e}")
            summary_data = {"error": f"Internal pipeline error: {e}"}
            
        finally:
            # 5. CLEANUP: Delete the file after processing
            os.remove(filepath)
            print(f"Cleaned up file: {filepath}")

        # 6. Render the results page, passing data including JSON for download
        return render_template(
            'index.html', 
            transcript=transcript,
            summary_data_json=json.dumps(summary_data), # <-- JSON string for download button
            summary=summary_data.get('summary', summary_data.get('error', 'N/A')),
            decisions=summary_data.get('key_decisions', []),
            actions=summary_data.get('action_items', []),
            success=True
        )

    else:
        return render_template('index.html', error='Invalid file type. Only MP3, WAV, M4A, FLAC allowed.')


@app.route('/download_summary', methods=['POST'])
def download_summary():
    """Generates the structured summary content as a text file and sends it for download."""
    
    # Get the combined summary text from the hidden form field
    summary_text_json = request.form.get('full_summary_text', '')
    
    if not summary_text_json:
        return "Error: Summary content missing.", 400

    # 1. Parse and format the data for a clean text file
    try:
        data = json.loads(summary_text_json)
        
        content = ""
        content += "========================================\n"
        content += "          MEETING SUMMARY\n"
        content += "========================================\n\n"
        
        content += "SUMMARY:\n"
        content += f"{data.get('summary', 'N/A')}\n\n"
        
        content += "--- KEY DECISIONS ---\n"
        for i, d in enumerate(data.get('key_decisions', [])):
            content += f"{i+1}. {d}\n"
            
        content += "\n--- ACTION ITEMS / TASKS ---\n"
        for i, a in enumerate(data.get('action_items', [])):
            content += f"{i+1}. {a}\n"
            
        content += "\n========================================\n"
        content += "Generated by ASR + LLM Pipeline"
            
    except json.JSONDecodeError:
        content = f"Error: Failed to parse summary data. Raw content:\n{summary_text_json}" 

    # 2. Use BytesIO to create the file in memory (avoids writing to disk)
    buffer = BytesIO()
    buffer.write(content.encode('utf-8'))
    buffer.seek(0)
    
    # 3. Send the file to the user
    return send_file(
        buffer,
        as_attachment=True,
        download_name='meeting_summary.txt',
        mimetype='text/plain'
    )

if __name__ == '__main__':
    app.run(debug=True)